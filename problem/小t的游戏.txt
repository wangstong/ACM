小t的游戏
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 529    Accepted Submission(s): 302


Problem Description
小t有点神经质，喜欢发明一些稀奇古怪的游戏，比如说左手和右手打架就是他发明的。
这个周末，小t又发明了一个有趣的硬币游戏：小t手里有6枚硬币，他把硬币分成了两堆，一左一右并排堆放，一堆2个，一堆4个。然后他开始从这两个堆中各取出1个硬币，再组成一个新的堆放在最右边。用(2,4)表示初始两堆，于是作下抽象，第一次操作后(2,4)变成了(1,3,2)。小t继续操作，他从这三堆中继续各取出1个硬币，组成新堆放到最右边。于是(1,3,2)变成了(0,2,1,3)，去掉空堆，变成(2,1,3)。小t继续进行以上操作并去除空堆，(2,1,3)变成了(1,2,3)。这时，小t发现如果继续做同样的动作，分堆的硬币不会再有变化了，一直都是(1,2,3)状态，也就是陷入了循环节为1的循环。
小t突发奇想，他想知道：如果知道硬币的分堆数，和每堆硬币的个数，执行“每次从已有的每一堆硬币中取出1个硬币，凑成新堆”的操作，用(a,b,c,d,….)表示分堆状态（其中a,b,c,d…每个字母都是正整数），分堆状态是否会陷入循环，如果陷入循环，循环节又是多少呢。

 

Input
输入有很多组case，每组case
第一行一个正整数n (n<65536)，表示硬币分为多少堆
第二行有n个整数，每个数k<65536，表示每堆有多少个硬币，每个数后面都有一个空格。
 

Output
如果分堆状态陷入循环，输出分两行，第一行输出yes，第二行输出一个整数表示循环节长度。
否则输出就一行no。
 

Sample Input
2
2 4
2
2 3
 

Sample Output
yes
1
yes
3